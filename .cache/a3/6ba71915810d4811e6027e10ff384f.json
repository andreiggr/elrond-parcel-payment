{"id":"node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/typeExpressionParser.js","dependencies":[{"name":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/typeExpressionParser.js.map","includedInParent":true,"mtime":1647170305389},{"name":"/Users/mac/code/work/bitmarket/elrond-parcel/package.json","includedInParent":true,"mtime":1647174146392},{"name":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/package.json","includedInParent":true,"mtime":1647170304850},{"name":"../../errors","loc":{"line":23,"column":36,"index":1011},"parent":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/typeExpressionParser.js","resolved":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/errors.js"},{"name":"./types","loc":{"line":24,"column":24,"index":1053},"parent":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/typeExpressionParser.js","resolved":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/types.js"},{"name":"json-duplicate-key-handle","loc":{"line":25,"column":26,"index":1091},"parent":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/typeExpressionParser.js","resolved":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/json-duplicate-key-handle/index.js"}],"generated":{"js":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeExpressionParser = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst types_1 = require(\"./types\");\nvar jsonHandler = require(\"json-duplicate-key-handle\");\nclass TypeExpressionParser {\n    parse(expression) {\n        let root = this.doParse(expression);\n        let rootKeys = Object.keys(root);\n        if (rootKeys.length != 1) {\n            throw new errors.ErrTypingSystem(`bad type expression: ${expression}`);\n        }\n        let name = rootKeys[0];\n        let type = this.nodeToType(name, root[name]);\n        return type;\n    }\n    doParse(expression) {\n        let jsoned = this.getJsonedString(expression);\n        try {\n            return jsonHandler.parse(jsoned);\n        }\n        catch (error) {\n            throw new errors.ErrTypingSystem(`cannot parse type expression: ${expression}. internal json: ${jsoned}.`);\n        }\n    }\n    /**\n     * Converts a raw type expression to a JSON, parsing-friendly format.\n     * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\n     *\n     * @param expression a string such as:\n     *\n     * ```\n     *  - Option<List<Address>>\n     *  - VarArgs<MultiArg2<bytes, Address>>\n     *  - MultiResultVec<MultiResult2<Address, u64>\n     * ```\n     */\n    getJsonedString(expression) {\n        let jsoned = \"\";\n        for (var i = 0; i < expression.length; i++) {\n            let char = expression.charAt(i);\n            let previousChar = expression.charAt(i - 1);\n            let nextChar = expression.charAt(i + 1);\n            if (char == \"<\") {\n                jsoned += \": {\";\n            }\n            else if (char == \">\") {\n                if (previousChar != \">\") {\n                    jsoned += \": {} }\";\n                }\n                else {\n                    jsoned += \"}\";\n                }\n            }\n            else if (char == \",\") {\n                if (nextChar == \">\") {\n                    // Skip superfluous comma\n                }\n                else {\n                    jsoned += \": {},\";\n                }\n            }\n            else {\n                jsoned += char;\n            }\n        }\n        // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\n        let symbolsRegex = /(:|\\{|\\}|,|\\s)/;\n        let tokens = jsoned\n            // Hack for Safari compatibility, where we can't use negative lookbehind\n            .replace(/utf\\-8\\sstring/ig, \"utf-8-string\")\n            .split(symbolsRegex)\n            .filter((token) => token);\n        jsoned = tokens.map((token) => (symbolsRegex.test(token) ? token : `\"${token}\"`))\n            .map((token) => token.replace(/utf\\-8\\-string/ig, \"utf-8 string\"))\n            .join(\"\");\n        if (tokens.length == 1) {\n            // Workaround for simple, non-generic types.\n            return `{${jsoned}: {}}`;\n        }\n        return `{${jsoned}}`;\n    }\n    nodeToType(name, node) {\n        if (name.charAt(name.length - 1) === \"1\") {\n            name = name.slice(0, -1);\n        }\n        let typeParameters = Object.keys(node).map((key) => this.nodeToType(key, node[key]));\n        return new types_1.Type(name, typeParameters);\n    }\n}\nexports.TypeExpressionParser = TypeExpressionParser;\n"},"sourceMaps":{"js":{"version":3,"file":"typeExpressionParser.js","sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/typeExpressionParser.ts"],"names":[],"mappings":"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","sourcesContent":[null]}},"error":null,"hash":"4784166b29b5e556a72a5c65cbf4f4c9","cacheData":{"env":{}}}