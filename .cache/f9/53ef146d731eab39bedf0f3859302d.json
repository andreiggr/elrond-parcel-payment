{"id":"node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/struct.js","dependencies":[{"name":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/struct.js.map","includedInParent":true,"mtime":1647170305345},{"name":"/Users/mac/code/work/bitmarket/elrond-parcel/package.json","includedInParent":true,"mtime":1647174146392},{"name":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/package.json","includedInParent":true,"mtime":1647170304850},{"name":"../../errors","loc":{"line":23,"column":36,"index":1072},"parent":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/struct.js","resolved":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/errors.js"},{"name":"./typeExpressionParser","loc":{"line":24,"column":39,"index":1129},"parent":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/struct.js","resolved":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/typeExpressionParser.js"},{"name":"./types","loc":{"line":25,"column":24,"index":1180},"parent":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/struct.js","resolved":"/Users/mac/code/work/bitmarket/elrond-parcel/node_modules/@elrondnetwork/erdjs/out/smartcontracts/typesystem/types.js"}],"generated":{"js":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StructField = exports.Struct = exports.StructFieldDefinition = exports.StructType = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst typeExpressionParser_1 = require(\"./typeExpressionParser\");\nconst types_1 = require(\"./types\");\nclass StructType extends types_1.CustomType {\n    constructor(name, fields) {\n        super(name);\n        this.fields = [];\n        this.fields = fields;\n    }\n    static fromJSON(json) {\n        let fields = (json.fields || []).map(field => StructFieldDefinition.fromJSON(field));\n        return new StructType(json.name, fields);\n    }\n}\nexports.StructType = StructType;\n// TODO: Perhaps rename to FieldDefinition and extract to separate file, fields.ts?\nclass StructFieldDefinition {\n    constructor(name, description, type) {\n        this.name = name;\n        this.description = description;\n        this.type = type;\n    }\n    static fromJSON(json) {\n        let parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);\n        return new StructFieldDefinition(json.name, json.description, parsedType);\n    }\n}\nexports.StructFieldDefinition = StructFieldDefinition;\n// TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\nclass Struct extends types_1.TypedValue {\n    /**\n     * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n     */\n    constructor(type, fields) {\n        super(type);\n        this.fields = [];\n        this.fields = fields;\n        this.checkTyping();\n    }\n    checkTyping() {\n        let fields = this.fields;\n        let type = this.getType();\n        let definitions = type.fields;\n        if (fields.length != definitions.length) {\n            throw new errors.ErrStructTyping(\"fields length vs. field definitions length\");\n        }\n        for (let i = 0; i < fields.length; i++) {\n            let field = fields[i];\n            let definition = definitions[i];\n            let fieldType = field.value.getType();\n            let definitionType = definition.type;\n            if (!fieldType.equals(definitionType)) {\n                throw new errors.ErrStructTyping(`check type of field \"${definition.name}; expected: ${definitionType}, actual: ${fieldType}\"`);\n            }\n            if (field.name != definition.name) {\n                throw new errors.ErrStructTyping(`check name of field \"${definition.name}\"`);\n            }\n        }\n    }\n    getFields() {\n        return this.fields;\n    }\n    valueOf() {\n        let result = {};\n        for (const field of this.fields) {\n            result[field.name] = field.value.valueOf();\n        }\n        return result;\n    }\n    equals(other) {\n        if (!this.getType().equals(other.getType())) {\n            return false;\n        }\n        let selfFields = this.getFields();\n        let otherFields = other.getFields();\n        if (selfFields.length != otherFields.length) {\n            return false;\n        }\n        for (let i = 0; i < selfFields.length; i++) {\n            let selfField = selfFields[i];\n            let otherField = otherFields[i];\n            if (!selfField.equals(otherField)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexports.Struct = Struct;\n// TODO: Perhaps rename to Field and extract to separate file, fields.ts?\nclass StructField {\n    constructor(value, name = \"\") {\n        this.value = value;\n        this.name = name;\n    }\n    equals(other) {\n        return this.name == other.name && this.value.equals(other.value);\n    }\n}\nexports.StructField = StructField;\n"},"sourceMaps":{"js":{"version":3,"file":"struct.js","sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/struct.ts"],"names":[],"mappings":"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","sourcesContent":[null]}},"error":null,"hash":"02a1c36f7f4e0a99e2e58dbbf4b9fe7b","cacheData":{"env":{}}}